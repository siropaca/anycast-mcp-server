# ADR-001: MCP Server による API 連携の採用

## ステータス

Accepted

## コンテキスト

Claude Code エージェントから anycast-backend の本番 API を操作し、チャンネル作成やエピソード作成を行いたい。
エージェントが安全かつ効率的に API を呼び出せる仕組みを選定する必要があった。

考慮したポイント:

- API キーのセキュリティ（プロンプトや Bash 履歴への露出防止）
- エージェントが正しいリクエスト形式で API を呼び出せること
- 操作スコープの制限（必要な操作のみ公開）
- メンテナンスコスト

## 決定

**MCP（Model Context Protocol）Server** を構築し、anycast-backend の REST API をラップする。

Claude Code の MCP Server 設定に登録することで、エージェントがネイティブのツールとして API 操作を実行できるようにする。

## 選択肢

### 選択肢 1: MCP Server

- **メリット**
  - Claude Code がネイティブのツールとして認識し、スキーマに基づいた呼び出しが可能
  - API キーを MCP Server の環境変数に閉じ込められる（プロンプトに露出しない）
  - ツール定義で操作スコープを明示的に制限できる（最小権限の原則）
  - 入力バリデーションをツール側で行えるため、不正なリクエストを事前に防げる
- **デメリット**
  - MCP Server の実装・メンテナンスが必要

### 選択肢 2: Bash + curl

- **メリット**
  - 追加実装が不要ですぐに使える
  - 既存の HTTP テストファイルをリファレンスにできる
- **デメリット**
  - API キーが Bash 履歴やプロンプトに露出するリスク
  - エンドポイントやリクエスト形式をエージェントが毎回正しく把握する必要がある
  - 操作スコープの制限ができない（任意の API を叩けてしまう）
  - エラーハンドリングがエージェント任せになる

### 選択肢 3: CLI ツール

- **メリット**
  - 型安全なインターフェースを提供できる
  - 既存の Go コードベースの型定義を再利用可能
- **デメリット**
  - CLI の実装・メンテナンスが必要
  - MCP ほど Claude Code との統合がスムーズでない（ツールスキーマの自動認識がない）
  - API キーの管理は別途必要

## 理由

1. **Claude Code との親和性**: MCP Server はツールスキーマを通じて Claude Code にネイティブ統合され、パラメータの型やバリデーションが自動的に伝達される
2. **セキュリティ**: API キーを環境変数として MCP Server プロセスに閉じ込めることで、会話コンテキストへの露出を防げる
3. **操作スコープの制限**: 公開するツールを明示的に定義でき、意図しない API 操作（削除など）をツールとして提供しない選択ができる
4. **エラーハンドリング**: HTTP レスポンスの解釈やエラーメッセージの整形を MCP Server 側で行い、エージェントにわかりやすいフィードバックを返せる

## 結果

- `anycast-mcp-server` リポジトリに MCP Server を実装する
- Claude Code の設定（`.claude/settings.json`）に MCP Server を登録する
- チャンネル・エピソード操作に必要なツールのみを公開する
- API キーは環境変数 `ANYCAST_API_KEY` で管理する
